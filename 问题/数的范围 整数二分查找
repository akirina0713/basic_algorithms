/*给定一个按照升序排列的长度为 n 的整数数组，以及 q个查询。
对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。
如果数组中不存在该元素，则返回 -1 -1。
输入格式
第一行包含整数 n 和 q，表示数组长度和询问个数。
第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。
接下来 q 行，每行包含一个整数 k，表示一个询问元素。
输出格式
共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。
如果数组中不存在该元素，则返回 -1 -1。*/   


/*用二分去查找元素要求数组的有序性或者拥有类似于有序的性质，对本题而言，
一个包含重复元素的有序序列，要求输出某元素出现的起始位置和终止位置，翻译一下就是：在数组中查找某元素，找不到就输出−1,−1，
找到了就输出不小于该元素的最小位置和不大于该元素的最大位置。所以，需要写两个二分，一个需要找到>=x>=𝑥的第一个数，另一个需要找到<=x<=𝑥的最后一个数。*/

#include<iostream>
using namespace std;
const int N = 100010;
int p[N];
int n, q;
int main()
{
    scanf("%d%d", &n, &q);
    for(int i = 0; i < n; i++) cin>>p[i];
    while(q --)
    {
        int x;
        cin>>x;
       int l = 0, r = n - 1;
      while(l < r)
     {
         int mid = l + r >> 1;   //寻找满足性质左边界的时候，为了保证mid可以取到左边界，必须向下取整, 即 mid = (L+R) >>1
         if(p[mid] >= x) r = mid;    //mid大于x，mid在x的右边，所以要修改右边界，此时找到的是左端点  
         else l = mid + 1;
     }
     
     if (p[l] != x) cout <<"-1 -1"<< endl;  //如果不存在，返回-1 -1
     else  //如果存在
     {
         cout << l << ' ';   //先输出第一次出现的位置
         int l = 0, r = n - 1;
         while(l < r)
         {
            int mid = l + r + 1 >> 1;   //寻找满足性质右边界的时候，为了保证mid可以取到右边界，必须向上取整，即 mid = (L+R+1) >> 1；
            if(p[mid] <= x) l = mid;    //mid小于x，mid在x的左边，所以要修改左边界，此时找到的是右端点
            else r = mid - 1;
         }
         cout<< l << endl;
     }
    }
    return 0;
}
