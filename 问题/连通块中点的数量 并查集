/*给定一个包含 n 个点（编号为 1∼n）的无向图，初始时图中没有边。
现在要进行 m 个操作，操作共有三种：
C a b，在点 a 和点 b 之间连一条边，a 和 b 可能相等；
Q1 a b，询问点 a 和点 b 是否在同一个连通块中，a 和 b 可能相等；
Q2 a，询问点 a 所在连通块中点的数量；
输入格式
第一行输入整数 n 和 m。
接下来 m 行，每行包含一个操作指令，指令为 C a b，Q1 a b 或 Q2 a 中的一种。
输出格式
对于每个询问指令 Q1 a b，如果 a 和 b 在同一个连通块中，则输出 Yes，否则输出 No。
对于每个询问指令 Q2 a，输出一个整数表示点 a 所在连通块中点的数量
每个结果占一行。*/

#include<isotream>
using namespace std;
const int N = 100010;
int n, m;
int p[N] ,size[N];
int find(int x)   //返回x的祖宗节点，同时对路径进行压缩
{
  if(x != p[x]) p[x] = find(p[x]);
  return p[x];
}

//合并a b所在的两个集合
void merge(int a, int b)
{
    int pa = find(a);//找到 a 所在集合的代表元素
    int pb = find(b);//找到 b 所在集合的代表元素
    if(pa != pb)//如果不是同一个，则属于不同集合，需要合并
    {
        p[pa] = pb;//将a集合合并到b集合中
    }
}

int main()
{
  scamnf("%d%d",&n, &m);
  for(int = 0; i <= n; i++) 
{
  p[i] = i;
  size[i] = 1;
}
  while(m --)
  {
    char op[5];
    int a, b;
    scanf("%s%d%d",op, &a, &b);
    if(op == 'C')
      {
        scanf("%d%d", &a, &b);
        if(find(a) == find(b)) contunie;
        size[find(b)] += size[find(a)];
        merge(a, b);
        
      }
    else if(op[1] == '1')
    {
        scanf("%d%d", &a, &b);
        if(find(a) == find(b)) puts("Yes");  /a和b在一个集合里面
        else puts("No");
    }
  else 
    {
      scanf("%d", &a);
      printf("%d", size[find(a)]);
    }
  }
return 0;
}
