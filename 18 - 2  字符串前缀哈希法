/*给定一个长度为 n 的字符串，再给定 m 个询问，每个询问包含四个整数 l1,r1,l2,r2请你判断 [l1,r1], 和 [l2,r2] 这两个区间所包含的字符串子串是否完全相同。
字符串中只包含大小写英文字母和数字。
输入格式
第一行包含整数 n 和 m，表示字符串长度和询问次数。
第二行包含一个长度为 n 的字符串，字符串中只包含大小写英文字母和数字。
接下来 m 行，每行包含四个整数 l1,r1,l2,r2，表示一次询问所涉及的两个区间。
注意，字符串的位置从 1 开始编号。
输出格式
对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 Yes，否则输出 No。每个结果占一行。*/

// 使用场景： 两个字符串的子串是否相同
//先将每一个前缀的哈希值求出来      运用了前缀和的思想
//只要能快速求出s[l1, r1] 和 s[l2,r2]对应的字符串的哈希值h[s[l1, r1]] h[s[l2, r2]]，并判断是否相等。就能得出l1, r1 l2,r2对应的字符串是否相同
//用到了 p 进制  将字符串转换成一个P进制的数字，例如 131 进制的数字。这个值看做字符串的哈希值h。
//p[x] = abcdef   从最高位开始存   f * p 的 5 次方 e * p 的 4 次方 ......    当求的值溢出时，就相当于模了 2 的 64 次方

#include<iostream>
using namespace std;

typedef unsigned long long ULL;

const int N = 100010, P = 131;   //P 一般取 131 比较好，不易出现重复现象 
int n, m;
char str[N];
ULL h[N], p[N];   //用p[N] 来存储  pow(P, r - l + 1)

ULL get(int l, int r)
{
  return h[r] - h[l-1] * p[r - l + 1];  // l 到 r 之间的哈希值     
  //区间和公式的理解: ABCDE 与 ABC 的前三个字符值是一样，只差两位，乘上P的二次方把 ABC 变为 ABC00，再用 ABCDE - ABC00 得到 DE 的哈希值。
}

int main()
{
  scanf("%d%d%s", &n, &m, str + 1);  //str 的下标从 1 开始
  p[0] = 1;
  for(int i = 1; i <= n; i++)
  {
    p[i] = p[i - 1] * P;
    h[i] = h[i-1] * P + str[i];  //类似前缀和
  }
  while(m --)
  {
    int l1, r1, l2, r2;
    scanf("%d%d%d%d", &l1, &r1, &l2, &r2);

    if(get(l1, r1) == get(l2, r2))  puts("Yes"); 
    else puts("No");
  }
}
